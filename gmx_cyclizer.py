#!/usr/bin/python
"""
Script for 
1. trimming and reordering atom indices in cyclic.top file
2. reordering atom indices in posre_cyclic.itp file
3. merging the receptor's .gro file and cyclic peptide's .gro file into one

(made by Joo-Chan Kim, Nov.8th 2021)

input parameters:
			command line parameters:
			1			name of cyclic.top file
			2			name of cyclic.gro file
			3	 opt		receptor's .gro file

output file:
			1			topol_cyclic.itp file
			2			posre_cyclic.itp file
			3			cyclic.gro or complex.gro file
"""

import sys
import math
import re
import os
import datetime
from operator import itemgetter


###
### Reading the topology file
###

if len(sys.argv) < 3:
	sys.exit("Too few arguments!")

topFileName = sys.argv[1]

if os.path.isfile(topFileName):
	topFile = open(topFileName, 'r')
else:
	sys.exit("No such file as "+topFileName+"!")

groFileName = sys.argv[2]
if os.path.isfile(groFileName):
	groFile = open(groFileName, 'r')
else:
	sys.exit("No such file as "+groFileName+"!")

receptorGroFileName = ''
if len(sys.argv) == 4:
	receptorGroFileName = sys.argv[3]
	if os.path.isfile(receptorGroFileName):
		receptorGroFile = open(receptorGroFileName, 'r')
	else:
		sys.exit("No such file as "+receptorGroFileName+"!")	

lines = topFile.readlines()
topFile.close()

atomsFlag = False
bondsFlag = False
pairsFlag = False
anglesFlag = False
dihedralsFlag = False
impropersFlag = False
cmapsFlag = False

residues = []
resnr = -1
bonds = []
pairs = []
angles = []
dihedrals = []
impropers = []
cmaps = []

for line in lines:
	line = line.strip()
	if len(line) > 0:
		segments = line.split()
		if segments[0] == '[':
			if segments[1] == 'atoms':
				atomsFlag = True
				continue
			elif segments[1] == 'bonds':
				atomsFlag = False
				bondsFlag = True
				continue
			elif segments[1] == 'pairs':
				bondsFlag = False
				pairsFlag = True
				continue
			elif segments[1] == 'angles':
				pairsFlag = False
				anglesFlag = True
				continue
			elif segments[1] == 'dihedrals':
				if not dihedralsFlag:
					anglesFlag = False
					dihedralsFlag = True
				else:
					dihedralsFlag = False
					impropersFlag = True

				continue
			elif segments[1] == 'cmap':
				impropersFlag = False
				cmapsFlag = True
				continue

		elif segments[0] == ';':
			if cmapsFlag and segments[1] == 'Include':
				break

		if atomsFlag:
			if segments[0] == ';' and segments[1] == 'residue':
				residues.append({'name':segments[3], 'charge':segments[7], 'atoms':[]})
				resnr += 1
			elif resnr >= 0:
				residues[resnr]['atoms'].append({'nr':segments[0], 'type':segments[1], 'name':segments[4], 'cgnr':segments[5], 'charge':segments[6], 'mass':segments[7]})
		
		elif bondsFlag and segments[0] != ';':
			bonds.append([segments[0], segments[1]])

		elif pairsFlag and segments[0] != ';':
			pairs.append([segments[0], segments[1]])

		elif anglesFlag and segments[0] != ';':
			angles.append([segments[0], segments[1], segments[2]])
		
		elif dihedralsFlag and segments[0] != ';':
			dihedrals.append([segments[0], segments[1], segments[2], segments[3]])

		elif impropersFlag and segments[0] != ';':
			impropers.append([segments[0], segments[1], segments[2], segments[3]])

		elif cmapsFlag and segments[0] != ';':
			cmaps.append([segments[0], segments[1], segments[2], segments[3], segments[4]])
			
nRes = len(residues)-2
nAtomsInFirstRes = len(residues[0]['atoms'])
ncgsInFirstRes = int(residues[0]['atoms'][-1]['cgnr'])

nAtoms = 0
for i in range(1, nRes+1):
	nAtoms += len(residues[i]['atoms'])

heavyAtomIndices = []
for i in range(1, nRes+1):
	for atom in residues[i]['atoms']:
		if atom['type'][0] != 'H':
			heavyAtomIndices.append(int(atom['nr'])-nAtomsInFirstRes)

###
### Writing topol_cyclic.itp file
###

now = datetime.datetime.now() 
nowDate = now.strftime('%Y-%m-%d')

topFile = open('topol_cyclic.itp', 'w')

topFile.write(';\n;\tGenerated by gmx_cyclizer.py at '+nowDate+' \n;\n\n')
topFile.write('[ moleculetype ]\n')
topFile.write('; Name            nrexcl\n')
topFile.write('cyclic               3\n\n')
topFile.write('[ atoms ]\n')
topFile.write(';   nr       type  resnr residue  atom   cgnr     charge       mass  typeB    chargeB      massB\n')

for i, res in enumerate(residues):
	topFile.write(f"; residue{i:>4d}{res['name']:>4s} rtp{res['name']:>4s}  q{res['charge']:>5s}\n")
	if i > 0 and i <= nRes:
		qtot = 0.0
		for atom in res['atoms']:
			nr = int(atom['nr'])-nAtomsInFirstRes
			cgnr = int(atom['cgnr'])-ncgsInFirstRes
			qtot += float(atom['charge'])
			topFile.write(f"{nr:>6d}{atom['type']:>11s}{i:>7d}{res['name']:>7s}{atom['name']:>7s}{cgnr:>7d}{atom['charge']:>11s}{atom['mass']:>11s}   ; qtot{qtot:>11.3f}\n")

topFile.write('\n[ bonds ]\n')
topFile.write(';  ai    aj funct            c0            c1            c2            c3\n')

for bond in bonds:
	ai = int(bond[0])
	aj = int(bond[1])
	
	if ai == 1:
		ai += 2
	elif aj == 1:
		aj += 2

	ai -= nAtomsInFirstRes
	aj -= nAtomsInFirstRes

	if ai > 0 and ai <= nAtoms:
		if aj > 0 and aj <= nAtoms:
			topFile.write(f"{ai:>5d}{aj:>6d}     1\n")
		elif aj <= 0:
			topFile.write(f"{ai:>5d}{aj+nAtoms:>6d}     1 ;cycle\n")
	elif ai <= 0:
		if aj > 0 and aj <= nAtoms:
			topFile.write(f"{ai+nAtoms:>5d}{aj:>6d}     1 ;cycle\n")


topFile.write('\n[ pairs ]\n')
topFile.write(';  ai    aj funct            c0            c1            c2            c3\n')

for pair in pairs:
	ai = int(pair[0])
	aj = int(pair[1])
	
	if ai == 1:
		ai += 2
	elif aj == 1:
		aj += 2

	ai -= nAtomsInFirstRes
	aj -= nAtomsInFirstRes

	if ai > 0 and ai <= nAtoms:
		if aj > 0 and aj <= nAtoms:
			topFile.write(f"{ai:>5d}{aj:>6d}     1\n")
		elif aj <= 0:
			topFile.write(f"{ai:>5d}{aj+nAtoms:>6d}     1 ;cycle\n")
	elif ai <= 0:
		if aj > 0 and aj <= nAtoms:
			topFile.write(f"{ai+nAtoms:>5d}{aj:>6d}     1 ;cycle\n")


topFile.write('\n[ angles ]\n')
topFile.write(';  ai    aj    ak funct            c0            c1            c2            c3\n')

for angle in angles:
	ai = int(angle[0])
	aj = int(angle[1])
	ak = int(angle[2])
	
	if ai == 1:
		ai += 2
	elif aj == 1:
		aj += 2
	elif ak == 1:
		ak += 2

	ai -= nAtomsInFirstRes
	aj -= nAtomsInFirstRes
	ak -= nAtomsInFirstRes

	outCount = 0

	if ai <= 0:
		ai += nAtoms
		outCount += 1
	elif ai > nAtoms:
		ai -= nAtoms
		outCount += 1

	if aj <= 0:
		aj += nAtoms
		outCount += 1
	elif aj > nAtoms:
		aj -= nAtoms
		outCount += 1

	if ak <= 0:
		ak += nAtoms
		outCount += 1
	elif ak > nAtoms:
		ak -= nAtoms
		outCount += 1

	if outCount < 2:
		topFile.write(f"{ai:>5d}{aj:>6d}{ak:>6d}     5")
		if outCount == 1:
			topFile.write(' ;cycle')
		topFile.write('\n')


topFile.write('\n[ dihedrals ]\n')
topFile.write(';  ai    aj    ak    al funct            c0            c1            c2            c3            c4            c5\n')

for dihedral in dihedrals:
	ai = int(dihedral[0])
	aj = int(dihedral[1])
	ak = int(dihedral[2])
	al = int(dihedral[3])
	
	if ai == 1:
		ai += 2
	elif aj == 1:
		aj += 2
	elif ak == 1:
		ak += 2
	elif al == 1:
		al += 2

	ai -= nAtomsInFirstRes
	aj -= nAtomsInFirstRes
	ak -= nAtomsInFirstRes
	al -= nAtomsInFirstRes

	outCount = 0
	inCount = 0

	if ai <= 0:
		ai += nAtoms
		outCount += 1
	elif ai > nAtoms:
		ai -= nAtoms
		outCount += 1

	if aj <= 0:
		aj += nAtoms
		outCount += 1
	elif aj > nAtoms:
		aj -= nAtoms
		outCount += 1

	if ak <= 0:
		ak += nAtoms
		outCount += 1
	elif ak > nAtoms:
		ak -= nAtoms
		outCount += 1
	elif outCount == 2:
		inCount += 1

	if al <= 0:
		al += nAtoms
		outCount += 1
	elif al > nAtoms:
		al -= nAtoms
		outCount += 1

	if (outCount == 2 and inCount == 1) or outCount < 2:
		topFile.write(f"{ai:>5d}{aj:>6d}{ak:>6d}{al:>6d}     9")
		if outCount != 0:
			topFile.write(' ;cycle')
		topFile.write('\n')
	


topFile.write('\n[ dihedrals ]\n')
topFile.write(';  ai    aj    ak    al funct            c0            c1            c2            c3            c4            c5\n')

for improper in impropers:
	ai = int(improper[0])
	aj = int(improper[1])
	ak = int(improper[2])
	al = int(improper[3])
	
	if ai == 1:
		ai += 2
	elif aj == 1:
		aj += 2
	elif ak == 1:
		ak += 2
	elif al == 1:
		al += 2

	ai -= nAtomsInFirstRes
	aj -= nAtomsInFirstRes
	ak -= nAtomsInFirstRes
	al -= nAtomsInFirstRes

	outCount = 0

	if ai <= 0:
		ai += nAtoms
		outCount += 1
	elif ai > nAtoms:
		ai -= nAtoms
		outCount += 1

	if aj <= 0:
		aj += nAtoms
		outCount += 1
	elif aj > nAtoms:
		aj -= nAtoms
		outCount += 1

	if ak <= 0:
		ak += nAtoms
		outCount += 1
	elif ak > nAtoms:
		ak -= nAtoms
		outCount += 1

	if al <= 0:
		al += nAtoms
		outCount += 1
	elif al > nAtoms:
		al -= nAtoms
		outCount += 1

	if outCount < 2:
		topFile.write(f"{ai:>5d}{aj:>6d}{ak:>6d}{al:>6d}     2")
		if outCount != 0:
			topFile.write(' ;cycle')
		topFile.write('\n')


topFile.write('\n[ cmap ]\n')
topFile.write(';  ai    aj    ak    al    am funct\n')

for cmap in cmaps:
	cyclicFlag = False
	for i, a in enumerate(cmap):
		a = int(a)
		if a == 1:
			a += 2
		a -= nAtomsInFirstRes

		if a <= 0:
			a += nAtoms
			cyclicFlag = True
		if a > nAtoms:
			a -= nAtoms
			cyclicFlag = True
		cmap[i] = a

	topFile.write(f"{cmap[0]:>5d}{cmap[1]:>6d}{cmap[2]:>6d}{cmap[3]:>6d}{cmap[4]:>6d}     1")

	if cyclicFlag:
		topFile.write("; cyclic\n")
	else:
		topFile.write("\n")


topFile.write('\n; Include Position restraint file\n')
topFile.write('#ifdef POSRES\n')
topFile.write('#include "posre_cyclic.itp"\n')
topFile.write('#endif\n')

topFile.close()


###
### Writing posre_cyclic.itp file
###

posreFile = open('posre_cyclic.itp', 'w')

posreFile.write(';\n;\tGenerated by gmx_cyclizer.py at '+nowDate+' \n;\n\n')
posreFile.write('[ position_restraints ]\n')
posreFile.write('; atom  type      fx      fy      fz\n')

for i in heavyAtomIndices:
	posreFile.write(f"{i:>6d}     1  1000  1000  1000\n")

posreFile.close()



###
### Writing the output .gro file
###

lines = groFile.readlines()
groFile.close()

atomCount = 1
atoms = []

for i, line in enumerate(lines):
	if i == 1:
		line = line.strip()
		atomCount = int(line)
	elif i > (atomCount+1):
		coordinates = line
	elif i != 0:
		segments = line.split()
		atom = {}
		atom['resi'] = segments[0]
		atom['name'] = segments[1]
		atom['number'] = segments[2]
		atom['x'] = segments[3]
		atom['y'] = segments[4]
		atom['z'] = segments[5]
		atoms.append(atom)

atomCount = 0
receptorAtoms = []

if receptorGroFileName == '':
	outFile = open('cyclic.gro', 'w')
else:
	lines = receptorGroFile.readlines()
	receptorGroFile.close()

	for i, line in enumerate(lines):
		if i == 1:
			line = line.strip()
			atomCount = int(line)
		elif i > (atomCount+1):
			coordinates = line
		elif i != 0:
			segments = line.split()
			atom = {}
			atom['resi'] = segments[0]
			atom['name'] = segments[1]
			atom['number'] = segments[2]
			atom['x'] = segments[3]
			atom['y'] = segments[4]
			atom['z'] = segments[5]
			receptorAtoms.append(atom)
	outFile = open('complex.gro', 'w')
	
outFile.write('GRoups of Organic Molecules in ACtion for Science\n')	# header
outFile.write(f' {nAtoms+atomCount}\n')

index = 0
for i in range(nAtomsInFirstRes, nAtoms+nAtomsInFirstRes):
	resi = atoms[i]['resi']
	name = atoms[i]['name']
	index += 1
	x = atoms[i]['x']
	y = atoms[i]['y']
	z = atoms[i]['z']
	outFile.write(f"{resi:>8s}{name:>7s}{index:>5d}{x:>8s}{y:>8s}{z:>8s}\n")

for i in range(atomCount):
	resi = receptorAtoms[i]['resi']
	name = receptorAtoms[i]['name']
	index += 1
	x = receptorAtoms[i]['x']
	y = receptorAtoms[i]['y']
	z = receptorAtoms[i]['z']
	outFile.write(f"{resi:>8s}{name:>7s}{index:>5d}{x:>8s}{y:>8s}{z:>8s}\n")

outFile.write(coordinates)	
outFile.close()
